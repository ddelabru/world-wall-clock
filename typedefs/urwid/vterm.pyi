# mypy: ignore-errors

import typing
from collections.abc import Callable as Callable, Iterable, Mapping, Sequence

from _typeshed import Incomplete
from typing_extensions import Literal
from urwid import event_loop as event_loop, util as util
from urwid.canvas import Canvas as Canvas
from urwid.display_common import AttrSpec as AttrSpec, RealTerminal as RealTerminal
from urwid.escape import (
    ALT_DEC_SPECIAL_CHARS as ALT_DEC_SPECIAL_CHARS,
    DEC_SPECIAL_CHARS as DEC_SPECIAL_CHARS,
)
from urwid.widget import Sizing as Sizing, Widget as Widget

EOF: bytes
ESC: Incomplete
ESC_B: bytes
KEY_TRANSLATIONS: Incomplete
KEY_TRANSLATIONS_DECCKM: Incomplete

class CSIAlias(typing.NamedTuple):
    alias_mark: str
    alias: bytes

class CSICommand(typing.NamedTuple):
    num_args: int
    default: int
    callback: Callable[[TermCanvas, list[int], bool], typing.Any]

CSI_COMMANDS: dict[bytes, CSIAlias | CSICommand]
CHARSET_DEFAULT: Literal[1]
CHARSET_UTF8: Literal[2]

class TermModes:
    display_ctrl: bool
    insert: bool
    lfnl: bool
    keys_decckm: bool
    reverse_video: bool
    constrain_scrolling: bool
    autowrap: bool
    visible_cursor: bool
    bracketed_paste: bool
    main_charset: Literal[1, 2]
    def reset(self) -> None: ...
    def __init__(
        self,
        display_ctrl,
        insert,
        lfnl,
        keys_decckm,
        reverse_video,
        constrain_scrolling,
        autowrap,
        visible_cursor,
        bracketed_paste,
        main_charset,
    ) -> None: ...

class TermCharset:
    MAPPING: typing.ClassVar[dict[str, str | None]]
    active: int
    current: Incomplete
    def __init__(self) -> None: ...
    def define(self, g: int, charset: str) -> None: ...
    def activate(self, g: int) -> None: ...
    def set_sgr_ibmpc(self) -> None: ...
    def reset_sgr_ibmpc(self) -> None: ...
    def apply_mapping(self, char: bytes) -> bytes: ...

class TermScroller(list):
    SCROLLBACK_LINES: int
    def __init__(self, iterable: Iterable[typing.Any]) -> None: ...
    def trunc(self) -> None: ...
    def append(self, obj) -> None: ...
    def insert(self, idx: typing.SupportsIndex, obj) -> None: ...
    def extend(self, seq) -> None: ...

class TermCanvas(Canvas):
    cacheable: bool
    widget: Incomplete
    modes: Incomplete
    has_focus: bool
    scrollback_buffer: Incomplete
    scrolling_up: int
    utf8_eat_bytes: Incomplete
    utf8_buffer: Incomplete
    escbuf: bytes
    term_cursor: Incomplete
    within_escape: bool
    parsestate: int
    attrspec: Incomplete
    charset: Incomplete
    saved_cursor: Incomplete
    saved_attrs: Incomplete
    is_rotten_cursor: bool
    scrollregion_start: int
    scrollregion_end: Incomplete
    tabstops: Incomplete
    term: Incomplete
    def __init__(self, width: int, height: int, widget: Terminal) -> None: ...
    cursor: Incomplete
    def set_term_cursor(self, x: int | None = ..., y: int | None = ...) -> None: ...
    def reset_scroll(self) -> None: ...
    def scroll_buffer(
        self, up: bool = ..., reset: bool = ..., lines: int | None = ...
    ) -> None: ...
    def reset(self) -> None: ...
    def init_tabstops(self, extend: bool = ...) -> None: ...
    def set_tabstop(
        self, x: int | None = ..., remove: bool = ..., clear: bool = ...
    ) -> None: ...
    def is_tabstop(self, x: int | None = ...) -> bool: ...
    def empty_line(
        self, char: bytes = ...
    ) -> list[tuple[AttrSpec | None, str | None, bytes]]: ...
    def empty_char(
        self, char: bytes = ...
    ) -> tuple[AttrSpec | None, str | None, bytes]: ...
    def addstr(self, data: Iterable[int]) -> None: ...
    width: Incomplete
    height: Incomplete
    def resize(self, width: int, height: int) -> None: ...
    def set_g01(self, char: bytes, mod: bytes) -> None: ...
    def parse_csi(self, char: bytes) -> None: ...
    def parse_noncsi(self, char: bytes, mod: bytes = ...) -> None: ...
    def parse_osc(self, buf: bytes) -> None: ...
    def parse_escape(self, char: bytes) -> None: ...
    def leave_escape(self) -> None: ...
    def get_utf8_len(self, bytenum: int) -> int: ...
    def addbyte(self, byte: int) -> None: ...
    def process_char(self, char: int | bytes) -> None: ...
    def set_char(
        self, char: bytes, x: int | None = ..., y: int | None = ...
    ) -> None: ...
    def constrain_coords(
        self, x: int, y: int, ignore_scrolling: bool = ...
    ) -> tuple[int, int]: ...
    def linefeed(self, reverse: bool = ...) -> None: ...
    def carriage_return(self) -> None: ...
    def newline(self) -> None: ...
    def move_cursor(
        self,
        x: int,
        y: int,
        relative_x: bool = ...,
        relative_y: bool = ...,
        relative: bool = ...,
    ) -> None: ...
    def push_char(self, char: bytes | None, x: int, y: int) -> None: ...
    def push_cursor(self, char: bytes | None = ...) -> None: ...
    def save_cursor(self, with_attrs: bool = ...) -> None: ...
    def restore_cursor(self, with_attrs: bool = ...) -> None: ...
    def tab(self, tabstop: int = ...) -> None: ...
    def scroll(self, reverse: bool = ...) -> None: ...
    def decaln(self) -> None: ...
    def blank_line(self, row: int) -> None: ...
    def insert_chars(
        self,
        position: tuple[int, int] | None = ...,
        chars: int = ...,
        char: bytes | None = ...,
    ) -> None: ...
    def remove_chars(
        self, position: tuple[int, int] | None = ..., chars: int = ...
    ) -> None: ...
    def insert_lines(self, row: int | None = ..., lines: int = ...) -> None: ...
    def remove_lines(self, row: int | None = ..., lines: int = ...) -> None: ...
    def erase(
        self,
        start: tuple[int, int] | tuple[int, int, bool],
        end: tuple[int, int] | tuple[int, int, bool],
    ) -> None: ...
    def sgi_to_attrspec(
        self,
        attrs: Sequence[int],
        fg: int,
        bg: int,
        attributes: set[str],
        prev_colors: int,
    ) -> AttrSpec | None: ...
    def csi_set_attr(self, attrs: Sequence[int]) -> None: ...
    def reverse_attrspec(
        self, attrspec: AttrSpec | None, undo: bool = ...
    ) -> AttrSpec: ...
    def reverse_video(self, undo: bool = ...) -> None: ...
    def set_mode(
        self,
        mode: Literal[1, 3, 4, 5, 6, 7, 20, 25, 2004],
        flag: bool,
        qmark: bool,
        reset: bool,
    ) -> None: ...
    def csi_set_modes(
        self, modes: Iterable[int], qmark: bool, reset: bool = ...
    ) -> None: ...
    def csi_set_scroll(self, top: int = ..., bottom: int = ...) -> None: ...
    def csi_clear_tabstop(self, mode: Literal[0, 3] = ...): ...
    def csi_get_device_attributes(self, qmark: bool) -> None: ...
    def csi_status_report(self, mode: Literal[5, 6]) -> None: ...
    def csi_erase_line(self, mode: Literal[0, 1, 2]) -> None: ...
    def csi_erase_display(self, mode: Literal[0, 1, 2]) -> None: ...
    def csi_set_keyboard_leds(self, mode: Literal[0, 1, 2, 3] = ...) -> None: ...
    def clear(self, cursor: tuple[int, int] | None = ...) -> None: ...
    def cols(self) -> int: ...
    def rows(self) -> int: ...
    def content(
        self,
        trim_left: int = ...,
        trim_right: int = ...,
        cols: int | None = ...,
        rows: int | None = ...,
        attr: Incomplete | None = ...,
    ): ...
    def content_delta(self, other): ...

class Terminal(Widget):
    signals: typing.ClassVar[list[str]]
    escape_sequence: Incomplete
    env: Incomplete
    command: Incomplete
    encoding: Incomplete
    keygrab: bool
    last_key: Incomplete
    response_buffer: Incomplete
    term_modes: Incomplete
    main_loop: Incomplete
    master: Incomplete
    pid: Incomplete
    width: Incomplete
    height: Incomplete
    term: Incomplete
    has_focus: bool
    terminated: bool
    def __init__(
        self,
        command: Sequence[str | bytes] | Callable[[], ...] | None,
        env: Mapping[str, str] | Iterable[tuple[str, str]] | None = ...,
        main_loop: event_loop.EventLoop | None = ...,
        escape_sequence: str | None = ...,
        encoding: str = ...,
    ) -> None: ...
    def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None: ...
    def spawn(self) -> None: ...
    def terminate(self) -> None: ...
    def beep(self) -> None: ...
    def leds(
        self, which: Literal["clear", "scroll_lock", "num_lock", "caps_lock"]
    ) -> None: ...
    def respond(self, string: str) -> None: ...
    def flush_responses(self) -> None: ...
    def set_termsize(self, width: int, height: int) -> None: ...
    def touch_term(self, width: int, height: int) -> None: ...
    def set_title(self, title) -> None: ...
    old_tios: Incomplete
    def change_focus(self, has_focus) -> None: ...
    def render(self, size: tuple[int, int], focus: bool = ...): ...
    def add_watch(self) -> None: ...
    def remove_watch(self) -> None: ...
    def wait_and_feed(self, timeout: float = ...) -> None: ...
    def feed(self) -> None: ...
    def keypress(self, size: tuple[int, int], key: str) -> str | None: ...
